// Generated by CoffeeScript 1.3.3
(function() {
  var casper, casperFactory, hasNext, links, llog, result, total, uniqueId, urlStem, x, _fn, _i, _len,
    __slice = [].slice;

  hasNext = function() {};

  llog = function() {
    var args, i, thread;
    thread = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    return console.log.apply(console, [((function() {
      var _i, _results;
      _results = [];
      for (i = _i = 0; 0 <= thread ? _i < thread : _i > thread; i = 0 <= thread ? ++_i : --_i) {
        _results.push("    ");
      }
      return _results;
    })()).join("")].concat(__slice.call(args)));
  };

  uniqueId = function(length) {
    var id;
    if (length == null) {
      length = 8;
    }
    id = "";
    while (id.length < length) {
      id += Math.random().toString(36).substr(2);
    }
    return id.substr(0, length);
  };

  links = [];

  casperFactory = require('casper');

  urlStem = "http://127.0.0.1:3000/new?workerId=";

  result = [0, 1, 2];

  _fn = function(x, casper) {
    var printIt, url;
    result[x] = {
      times: [],
      election: false,
      error: false
    };
    url = urlStem + uniqueId();
    casper.start(url, function() {
      llog(x, "hmmm...");
      result[x].times[0] = (new Date()).getTime();
      llog(x, "logout", this.evaluate(function() {
        return newUser();
      }));
      return this.open(url);
    });
    casper.waitForSelector("#nextStep", (function() {
      result[x].times[1] = (new Date()).getTime();
      llog(x, "result");
      llog(x, "hi");
      llog(x, result[x].times);
      llog(x, "I've waited for " + (result[x].times[1] - result[x].times[0]) + "   " + total);
      total += 1;
      this.waitForSelector("#nextStep", (function() {
        llog(x, "Got #nextStep twice, clicking");
        try {
          this.click("#nextStep");
          return llog(x, "clicked");
        } catch (e) {
          llog(x, "QQQQQQQQQ", e);
          llog(x, this.getHTML("body"));
          return llog(x, this.exists("#nextStep"));
        }
      }), (function() {
        return llog(x, "too slow dude");
      }), 30000);
      return true;
    }), function() {
      result[x].error = true;
      return llog(x, "timed out suckah" + x + " after " + (new Date().getTime() - result[x].times[0]));
    }, 60000);
    casper.then(function() {
      return llog(x, "then");
    });
    printIt = true;
    (function(printIt) {
      return casper.waitFor((function() {
        var election, key, results, step, val, _ref, _ref1;
        results = this.evaluate(function() {
          return [Session.get("step"), ELECTION];
        });
        llog(x, "step,election=", results);
        step = results[0], election = results[1];
        if (step !== void 0) {
          if (printIt) {
            _ref = election || {};
            for (key in _ref) {
              val = _ref[key];
              llog(x, key, val);
            }
            llog(x, "THE step", step);
            printIt = false;
          }
        } else {
          llog(x, "no", step, election);
        }
        if ((_ref1 = result[x]) != null) {
          _ref1.election = election;
        }
        return step === 2;
      }), (function() {
        result[x].times[2] = (new Date()).getTime();
        llog(x, "2. I've waited for " + (result[x].times[2] - result[x].times[1]) + "   " + total);
        return this.waitForSelector("#nextStep", (function() {
          llog(x, "Got #nextStep twice, clicking");
          try {
            this.click("#nextStep");
            return llog(x, "clicked");
          } catch (e) {
            llog(x, "QQQQQQQQQ", e);
            llog(x, this.getHTML("body"));
            return llog(x, this.exists("#nextStep"));
          }
        }), (function() {
          return llog(x, "too slow dude");
        }), 30000);
      }), function() {
        result[x].error = true;
        return llog(x, "timed out suckah2" + x + " after " + (new Date().getTime() - result[x].times[0]));
      }, 60000);
    })(printIt);
    casper.waitFor(function() {
      var step;
      step = this.evaluate(function() {
        return Session.get("step");
      });
      return step === 3;
    }, function() {
      result[x].times[3] = (new Date()).getTime();
      llog(x, "3. I've waited for " + (result[x].times[3] - result[x].times[2]) + "   " + total);
      return this.waitForSelector("#nextStep", (function() {
        llog(x, "Got #nextStep twice, clicking");
        try {
          this.click("#nextStep");
          return llog(x, "clicked");
        } catch (e) {
          llog(x, "QQQQQQQQQ", e);
          llog(x, this.getHTML("body"));
          return llog(x, this.exists("#nextStep"));
        }
      }), (function() {
        return llog(x, "too slow dude");
      }), 30000);
    }, function() {
      result[x].error = true;
      return llog(x, "timed out suckah2" + x + " after " + (new Date().getTime() - result[x].times[0]));
    }, 60000);
    return casper.run(function() {
      llog(x, "method counts: ", _.countBy(result, function(aResult) {
        return aResult.election.method;
      }));
      return llog(x, "done!!!!", x, results);
    });
  };
  for (_i = 0, _len = result.length; _i < _len; _i++) {
    x = result[_i];
    total = 1;
    llog(x, "hi");
    casper = casperFactory.create();
    _fn(x, casper);
  }

}).call(this);
